
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>37. Read-Dominated Workloads &#8212; Introduction to Operating Systems</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="38. Challenges of Modern Hardware" href="hardware_challenges.html" />
    <link rel="prev" title="36. Common Concurrency Bugs" href="concurrency_bugs.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Introduction to Operating Systems</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro/pref.html">
                    Preface
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/intro.html">
   1. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/purpose.html">
   2. Purpose of operating systems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/structure.html">
   3. Operating System Structure &amp; Unix/Linux
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/abstractions.html">
   4. Operating System Abstractions
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../intro/tools.html">
   5. What you should know
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-shell.html">
     5.1. Shell
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-editors.html">
     5.2. Editors
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-make.html">
     5.3. Makefiles
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-git.html">
     5.4. Git Basics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-gdb.html">
     5.5. GDB
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-c.html">
     5.6. The C Programming Language
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-testing.html">
     5.7. Unit Tests
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Virtual Processor
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../scheduling/intro.html">
   6. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../scheduling/process.html">
   7. Virtualizing a CPU
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../scheduling/scheduling.html">
   8. Scheduling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../scheduling/real_sched.html">
   9. A Look at the Linux Scheduler
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  File Systems
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/intro.html">
   10. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/interface.html">
   11. File System Abstraction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/diskhw.html">
   12. A bit about Disks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/disklayout.html">
   13. File System Layout
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/dl_track_used.html">
   14. Disk Layout:Tracking Used Space
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/dl_track_free.html">
   15. Disk Layout:Tracking Free Space
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/dl_name.html">
   16. Disk Layout:Implementing Name Space
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/dl_failures.html">
   17. Disk Layout:Dealing with Failures
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/dl_ex_exx.html">
   18. Disk Layout:Examples of Real World File Systems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/kernelimp.html">
   19. Kernel implementation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Virtual Memory
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/intro.html">
   20. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/phys-and-seg.html">
   21. Memory management before paged virtual memory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/virt-paging.html">
   22. Paging
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/page-tables.html">
   23. Page Tables
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/reclamation.html">
   24. Memory reclaiming algorithms.
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/page-size.html">
   25. Page Sizes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/misc.html">
   26. Other topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/buffer-cache.html">
   27. Buffer Cache
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/pagefaults.html">
   28. Memory Management Dynamics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/realworld.html">
   29. Memory management in the real world
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/concl.html">
   30. Conclusion
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Concurrency
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="sync.html">
   31. Introduction to Concurrency, Synchronization and Deadlock
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sharing.html">
   32. Cooperating Processes and Inter-process Communication
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="criticalsection.html">
   33. The Critical Section Problem
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="locks.html">
   34. Implementing Locks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ordering.html">
   35. Ordering Thread Events
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="concurrency_bugs.html">
   36. Common Concurrency Bugs
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   37. Read-Dominated Workloads
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hardware_challenges.html">
   38. Challenges of Modern Hardware
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linux_locking.html">
   39. Locking in the Linux Kernel
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Other Topics
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../devices/devices.html">
   40. Input and Output
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../devices/disk2.html">
   41. More on Disks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../virt/virt.html">
   42. Virtualization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sec/sec.html">
   43. Security
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Appendices
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../misc/howto.html">
   44. How to read this book
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../contributing/Contributing.html">
   45. Contributing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../misc/bib.html">
   46. Bibliography
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://jupyterhub-opf-jupyterhub.apps.smaug.na.operate-first.cloud/hub/user-redirect/git-pull?repo=https%3A//github.com/OpenOSOrg/openos&urlpath=lab/tree/openos/content/sync/readmostly.ipynb&branch=main"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on JupyterHub"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_jupyterhub.svg">
  </span>
<span class="headerbtn__text-container">JupyterHub</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/OpenOSOrg/openos"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/OpenOSOrg/openos/issues/new?title=Issue%20on%20page%20%2Fsync/readmostly.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/OpenOSOrg/openos/edit/main/content/sync/readmostly.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="headerbtn__text-container">suggest edit</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/sync/readmostly.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#reader-writer-locks">
   37.1. Reader-Writer Locks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#performance-of-reader-writer-locks">
   37.2. Performance of Reader/Writer Locks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#read-copy-update">
   37.3. Read-Copy Update
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#why-rcu">
     37.3.1. Why RCU?
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-read-side">
     37.3.2. The read-side
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-write-side">
     37.3.3. The write-side
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#handling-read-reclaim-races">
     37.3.4. Handling read-reclaim races
    </a>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Read-Dominated Workloads</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#reader-writer-locks">
   37.1. Reader-Writer Locks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#performance-of-reader-writer-locks">
   37.2. Performance of Reader/Writer Locks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#read-copy-update">
   37.3. Read-Copy Update
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#why-rcu">
     37.3.1. Why RCU?
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-read-side">
     37.3.2. The read-side
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-write-side">
     37.3.3. The write-side
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#handling-read-reclaim-races">
     37.3.4. Handling read-reclaim races
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <div class="cell tag_remove-input docutils container">
</div>
<section class="tex2jax_ignore mathjax_ignore" id="read-dominated-workloads">
<span id="cont-sync-readmostly"></span><h1><span class="section-number">37. </span>Read-Dominated Workloads<a class="headerlink" href="#read-dominated-workloads" title="Permalink to this headline">#</a></h1>
<p>There are many scenarios in operating systems and other concurrent software where certain data structures are frequently read, but rarely updated. For example, the OS caches network routing information, but route updates are infrequent compared to route lookups in the cache. Since read-only accesses cannot conflict with each other, we would like to allow “readers” to execute concurrently with each other (sharing access to the data structure), while “writers” must not be allowed to conflict with either readers or other writers. We will look at two ways to solve this problem: classical reader-writer locks (rw_locks), and read-copy-update (RCU).</p>
<section id="reader-writer-locks">
<span id="cont-sync-readmostly-rw-locks"></span><h2><span class="section-number">37.1. </span>Reader-Writer Locks<a class="headerlink" href="#reader-writer-locks" title="Permalink to this headline">#</a></h2>
<p>Courtois et al. first described the reader-writer problem and two solutions using semaphores for mutual exclusion in 1971 <span id="id1">[<a class="reference internal" href="../misc/bib.html#id16" title="P. J. Courtois, F. Heymans, and D. L. Parnas. Concurrent control with “readers” and “writers”. Commun. ACM, 14(10):667–668, oct 1971. URL: https://doi.org/10.1145/362759.362813, doi:10.1145/362759.362813.">CHP71</a>]</span>. In the first version of the problem, readers have priority over writers: a reader thread should never be prevented from accessing the resource unless a writer has already been granted exclusive use of the resource. We show the solution for this reader-priority version in <a class="reference internal" href="#listing-sync-readmostly-readerpri"><span class="std std-numref">Listing 37.1</span></a> using POSIX semaphores. Note that since the semaphores are used only for mutual exclusion, we could replace them with <code class="docutils literal notranslate"><span class="pre">pthread_mutex_t</span></code> or any of our spinlock implementations without making any other changes. We represent access to some shared database with the <code class="docutils literal notranslate"><span class="pre">read_db()</span></code> and <code class="docutils literal notranslate"><span class="pre">write_db()</span></code> functions.</p>
<div class="literal-block-wrapper docutils container" id="listing-sync-readmostly-readerpri">
<div class="code-block-caption"><span class="caption-number">Listing 37.1 </span><span class="caption-text">Reader/writer solution using semaphores; readers have priority over writers.</span><a class="headerlink" href="#listing-sync-readmostly-readerpri" title="Permalink to this code">#</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">static</span> <span class="n">void</span> <span class="n">read_db</span><span class="p">();</span>
<span class="linenos"> 2</span><span class="n">static</span> <span class="n">void</span> <span class="n">write_db</span><span class="p">();</span>
<span class="linenos"> 3</span>
<span class="hll"><span class="linenos"> 4</span><span class="n">sem_t</span> <span class="n">mutex</span><span class="p">;</span>         <span class="o">/*</span> <span class="n">Initially</span> <span class="mi">1</span> <span class="o">*/</span>
</span><span class="hll"><span class="linenos"> 5</span><span class="n">sem_t</span> <span class="n">counter_mutex</span><span class="p">;</span> <span class="o">/*</span> <span class="n">Initially</span> <span class="mi">1</span> <span class="o">*/</span>
</span><span class="hll"><span class="linenos"> 6</span><span class="nb">int</span> <span class="n">reader_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="n">static</span> <span class="n">void</span> <span class="n">writer</span><span class="p">()</span>
<span class="linenos"> 9</span><span class="p">{</span>
<span class="hll"><span class="linenos">10</span>    <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span><span class="linenos">11</span>    <span class="n">write_db</span><span class="p">();</span>
<span class="hll"><span class="linenos">12</span>    <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span><span class="linenos">13</span><span class="p">}</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="n">static</span> <span class="n">void</span> <span class="n">reader</span><span class="p">()</span>
<span class="linenos">16</span><span class="p">{</span>
<span class="linenos">17</span>    
<span class="hll"><span class="linenos">18</span>    <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter_mutex</span><span class="p">);</span>
</span><span class="hll"><span class="linenos">19</span>    <span class="n">reader_count</span><span class="o">++</span><span class="p">;</span>
</span><span class="hll"><span class="linenos">20</span>    <span class="k">if</span> <span class="p">(</span><span class="n">reader_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll"><span class="linenos">21</span>        <span class="o">/*</span> <span class="n">first</span> <span class="n">reader</span> <span class="n">synchronizes</span> <span class="k">with</span> <span class="n">writers</span> <span class="n">to</span> <span class="n">acquire</span> <span class="n">the</span> <span class="n">resource</span> <span class="o">*/</span>
</span><span class="hll"><span class="linenos">22</span>        <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span><span class="hll"><span class="linenos">23</span>    <span class="p">}</span>
</span><span class="hll"><span class="linenos">24</span>    <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter_mutex</span><span class="p">);</span>
</span><span class="linenos">25</span>    
<span class="linenos">26</span>    <span class="n">read_db</span><span class="p">();</span>
<span class="linenos">27</span>    
<span class="hll"><span class="linenos">28</span>    <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter_mutex</span><span class="p">);</span>
</span><span class="hll"><span class="linenos">29</span>    <span class="n">reader_count</span><span class="o">--</span><span class="p">;</span>
</span><span class="hll"><span class="linenos">30</span>    <span class="k">if</span> <span class="p">(</span><span class="n">reader_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll"><span class="linenos">31</span>        <span class="o">/*</span> <span class="n">last</span> <span class="n">reader</span> <span class="n">releases</span> <span class="n">the</span> <span class="n">resource</span> <span class="o">*/</span>
</span><span class="hll"><span class="linenos">32</span>        <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span><span class="hll"><span class="linenos">33</span>    <span class="p">}</span>
</span><span class="hll"><span class="linenos">34</span>    <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter_mutex</span><span class="p">);</span>
</span><span class="linenos">35</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>The writer code (lines 11-13) is very simple. We introduce a <code class="docutils literal notranslate"><span class="pre">mutex</span></code> semaphore (line 4) to protect access to the shared database. The <code class="docutils literal notranslate"><span class="pre">wait</span></code> on <code class="docutils literal notranslate"><span class="pre">mutex</span></code> at line 10 ensures that only one writer can be accessing the database at any time; when the writer is done, it <code class="docutils literal notranslate"><span class="pre">post</span></code>s a notice to <code class="docutils literal notranslate"><span class="pre">mutex</span></code> that the database is now available again (line 12). The reader code needs to do a little more work, however, because we want to allow multiple readers. First, we want to keep track of the number of readers currently accessing the database, so we introduce a <code class="docutils literal notranslate"><span class="pre">reader_count</span></code> variable (line 6), and since this variable will be updated by every reader thread, we also add a <code class="docutils literal notranslate"><span class="pre">counter_mutex</span></code> semaphore (line 5) to protect sections of code that depend on the <code class="docutils literal notranslate"><span class="pre">reader_count</span></code>. Each reader thread begins by <code class="docutils literal notranslate"><span class="pre">wait</span></code>ing for the <code class="docutils literal notranslate"><span class="pre">counter_mutex</span></code>, then increments <code class="docutils literal notranslate"><span class="pre">reader_count</span></code> to add itself to the count of current readers (lines 18-19). Only the first reader thread needs to synchronize with writer threads (lines 20-23)—once a reader has successfully <code class="docutils literal notranslate"><span class="pre">wait</span></code>ed for the <code class="docutils literal notranslate"><span class="pre">mutex</span></code>, writers will be locked out until all the readers are done. Notice also that the first reader does not <code class="docutils literal notranslate"><span class="pre">post</span></code> to the <code class="docutils literal notranslate"><span class="pre">counter_mutex</span></code> until <em>after</em> it has obtained permission to access the database (line 24). This ensures that other reader threads must line up <code class="docutils literal notranslate"><span class="pre">wait</span></code>ing for the <code class="docutils literal notranslate"><span class="pre">counter_mutex</span></code> as long as a writer is accessing the database; once the first reader obtains access to the database, the other readers only need to increment the <code class="docutils literal notranslate"><span class="pre">reader_count</span></code>. When a reader finishes using the database, it must again <code class="docutils literal notranslate"><span class="pre">wait</span></code> for the <code class="docutils literal notranslate"><span class="pre">counter_mutex</span></code> to subtract itself from the count of current readers (lines 28-29). When the <code class="docutils literal notranslate"><span class="pre">reader_count</span></code> falls to zero, it means that the last reader thread is done using the database, and this last thread must <code class="docutils literal notranslate"><span class="pre">post</span></code> a signal to the <code class="docutils literal notranslate"><span class="pre">mutex</span></code> to indicate that the database is available again (lines 30-33). If any writers are waiting, one will now be allowed to proceed; otherwise the database remains available until either a reader or writer threads requests access.</p>
<p>The reader code illustrates the <em>lightswitch pattern</em> in concurrent programming: the analogy is that the first person into a dark room turns on the light (acquires the resource), and the last one to leave turns it off (releases the resource).</p>
<p>We can encapsulate the <em>entry</em> sections of code (line 10 for writers; lines 18-24 for readers) and the <em>exit</em> sections of code (line 12 for writers; lines 28-34 for readers) into acquire and release functions for reader/writer locks. This code is shown in <a class="reference internal" href="#listing-sync-readmostly-rwlock"><span class="std std-numref">Listing 37.2</span></a>:</p>
<div class="literal-block-wrapper docutils container" id="listing-sync-readmostly-rwlock">
<div class="code-block-caption"><span class="caption-number">Listing 37.2 </span><span class="caption-text">C source code for reader/writer locks using semaphores.</span><a class="headerlink" href="#listing-sync-readmostly-rwlock" title="Permalink to this code">#</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">#include &lt;semaphore.h&gt;</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">rwlock_s</span> <span class="p">{</span>
<span class="linenos"> 4</span>    <span class="n">sem_t</span> <span class="n">mutex</span><span class="p">;</span>
<span class="linenos"> 5</span>    <span class="n">sem_t</span> <span class="n">counter_mutex</span><span class="p">;</span>
<span class="linenos"> 6</span>    <span class="nb">int</span> <span class="n">reader_count</span><span class="p">;</span>
<span class="linenos"> 7</span><span class="p">}</span> <span class="n">rwlock_t</span><span class="p">;</span> 
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="n">static</span> <span class="n">inline</span> <span class="n">void</span> <span class="n">rwlock_init</span><span class="p">(</span><span class="n">rwlock_t</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">10</span>    <span class="n">l</span><span class="o">-&gt;</span><span class="n">reader_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="linenos">11</span>    <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">counter_mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="linenos">12</span>    <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="linenos">13</span><span class="p">}</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="n">static</span> <span class="n">inline</span> <span class="n">void</span> <span class="n">rwlock_acquire_write</span><span class="p">(</span><span class="n">rwlock_t</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="linenos">16</span><span class="p">{</span>
<span class="linenos">17</span>    <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="linenos">18</span><span class="p">}</span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="n">static</span> <span class="n">inline</span> <span class="n">void</span> <span class="n">rwlock_release_write</span><span class="p">(</span><span class="n">rwlock_t</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="linenos">21</span><span class="p">{</span>
<span class="linenos">22</span>    <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="linenos">23</span><span class="p">}</span>
<span class="linenos">24</span>
<span class="linenos">25</span><span class="n">static</span> <span class="n">inline</span> <span class="n">void</span> <span class="n">rwlock_acquire_read</span><span class="p">(</span><span class="n">rwlock_t</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="linenos">26</span><span class="p">{</span>
<span class="linenos">27</span>    <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">counter_mutex</span><span class="p">);</span>
<span class="linenos">28</span>    <span class="n">l</span><span class="o">-&gt;</span><span class="n">reader_count</span><span class="o">++</span><span class="p">;</span>
<span class="linenos">29</span>    <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">reader_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">30</span>        <span class="o">/*</span> <span class="n">first</span> <span class="n">reader</span> <span class="n">synchronizes</span> <span class="k">with</span> <span class="n">writers</span> <span class="n">to</span> <span class="n">acquire</span> <span class="n">the</span> <span class="n">resource</span> <span class="o">*/</span>
<span class="linenos">31</span>        <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="linenos">32</span>    <span class="p">}</span>
<span class="linenos">33</span>    <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">counter_mutex</span><span class="p">);</span>   
<span class="linenos">34</span><span class="p">}</span>
<span class="linenos">35</span>
<span class="linenos">36</span><span class="n">static</span> <span class="n">inline</span> <span class="n">void</span> <span class="n">rwlock_release_read</span><span class="p">(</span><span class="n">rwlock_t</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="linenos">37</span><span class="p">{</span>
<span class="linenos">38</span>    <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">counter_mutex</span><span class="p">);</span>
<span class="linenos">39</span>    <span class="n">l</span><span class="o">-&gt;</span><span class="n">reader_count</span><span class="o">--</span><span class="p">;</span>
<span class="linenos">40</span>    <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">reader_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">41</span>        <span class="o">/*</span> <span class="n">last</span> <span class="n">reader</span> <span class="n">releases</span> <span class="n">the</span> <span class="n">resource</span> <span class="o">*/</span>
<span class="linenos">42</span>        <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="linenos">43</span>    <span class="p">}</span>
<span class="linenos">44</span>    <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">counter_mutex</span><span class="p">);</span>
<span class="linenos">45</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>We could combine the release functions and just have a single <code class="docutils literal notranslate"><span class="pre">rwlock_release()</span></code> function invoked by either reader or writer threads. When a writer releases the lock, the <code class="docutils literal notranslate"><span class="pre">reader_count</span></code> should already be <code class="docutils literal notranslate"><span class="pre">0</span></code>; in that case we skip decrementing <code class="docutils literal notranslate"><span class="pre">reader_count</span></code> and just post to the <code class="docutils literal notranslate"><span class="pre">mutex</span></code>. This is the approach taken by the pthreads library implementation of reader/writer locks (<code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">-k</span> <span class="pre">pthread_rwlock</span></code>).</p>
<p>In this implementation of rwlocks, intensive read activity could starve writer threads. An alternative is to give writers priority: as soon as a writer thread requests access to the shared data, no new reader threads are allowed access until the writer is done using the data. The writer must still wait for existing reader threads to finish and release the data, but writers will not starve. If write activity is intense enough to worry about starving readers, then rwlocks are probably not a good choice anyway.</p>
</section>
<section id="performance-of-reader-writer-locks">
<h2><span class="section-number">37.2. </span>Performance of Reader/Writer Locks<a class="headerlink" href="#performance-of-reader-writer-locks" title="Permalink to this headline">#</a></h2>
<p>To be added.</p>
<p>Takeaway: The reader side of reader/writer locks is expensive, since an internal lock must be acquired and released on <em>every</em> <code class="docutils literal notranslate"><span class="pre">rwlock_acquire_read</span></code> and <code class="docutils literal notranslate"><span class="pre">rwlock_release_read</span></code> to modify the <code class="docutils literal notranslate"><span class="pre">reader_count</span></code> and check if the current thread is either the first (on acquire) or last (on release) reader. For short read-side critical sections, the overhead of rwlocks can overwhelm the benefit of allowing readers to access the shared data structure concurrently with each other.</p>
</section>
<section id="read-copy-update">
<span id="cont-sync-readmostly-rcu"></span><h2><span class="section-number">37.3. </span>Read-Copy Update<a class="headerlink" href="#read-copy-update" title="Permalink to this headline">#</a></h2>
<p><em>Read-Copy Update</em> (RCU) is an alternative reader/writer synchronization mechanism designed for read-mostly data structures. Readers use no locks at all, thereby addressing the read-side overhead of rwlocks. Writers only need to synchronize with other writers, typically by using ordinary locks. Thus, RCU lets multiple readers access data concurrently with one writer. The key property we need to ensure is that readers always see a consistent version of the data, either before a writer performs an update, or after the update is complete. To achieve this, writers must create new versions of the data atomically, for example, by making a copy of a node in a data structure that they want to update, performing the update on the copy, and atomically replacing the old copy with the new copy into the data structure. Concurrent readers can continue to access the old version of the data; new readers will see the update. Of course, the old version must be deleted at some point, but only after we are able to guarantee that no reader can be accessing it.</p>
<p>Unlike with reader/writer locks, RCU readers can read stale data and may see inconsistencies (for example, an RCU reader counting the number of items in a linked list might return a total that would not be possible under reader/writer locking). However, there are many situations where this staleness and inconsistency doesn’t matter. Paul McKenney uses the example of the network routing table in one of his <a class="reference external" href="https://lwn.net/Articles/263130/">RCU LWN article</a>:</p>
<blockquote>
<div><p>Because routing updates can take considerable time to reach a given system (seconds or even minutes), the system will have been sending packets the wrong way for quite some time when the update arrives. It is usually not a problem to continue sending updates the wrong way for a few additional milliseconds.</p>
</div></blockquote>
<p>Although RCU readers use no locking, we still need to reason about reader accesses to shared data, to determine when it is safe for a writer to reclaim memory. Thus, we refer to the sections of code where readers are accessing a shared data structure as a <em>read-side critical section</em>, and we impose some restrictions on what threads are allowed to do in a read-side critical section.</p>
<p>We will present RCU with reference to the Linux kernel implementation. An excellent resource for further reading on this topic can be found in the [Linux kernel documentation of RCU]<code class="docutils literal notranslate"><span class="pre">https://www.kernel.org/doc/html/latest/RCU/whatisRCU.html</span></code>.</p>
<section id="why-rcu">
<h3><span class="section-number">37.3.1. </span>Why RCU?<a class="headerlink" href="#why-rcu" title="Permalink to this headline">#</a></h3>
<p>Before we dive into RCU and how it works in more detail, we will motivate the RCU approach using the example of a concurrent hash table, as depicted in <a class="reference internal" href="#fig-sync-readmostly-rcu-hashtable"><span class="std std-numref">Fig. 37.1</span></a>. Such data structures are widely used in operating systems, for example to build caches of network routing information or file system metadata, and to locate data structures like the thread structure given a key like the thread identifier. To look up a key in the hashtable, a hash function selects a bucket (i.e., an entry in an array). Collisions are handled by chaining, so once we have found the right bucket, we will need to search the linked list of items that hash to the same bucket. Since the hashtable can be accessed by multiple threads concurrently searching for items, inserting new items, or deleting items, we will need some synchronization. Rather than a single lock on the entire hashtable, we can increase concurrency by using a separate lock for each bucket in the hashtable. Because each bucket has its own lock, we can simplify the scenario by just thinking about concurrent operations on a linked list; operations that hash to different buckets will not conflict with each other.</p>
<figure class="align-default" id="fig-sync-readmostly-rcu-hashtable">
<a class="reference internal image-reference" href="../_images/hashtable.drawio.png"><img alt="../_images/hashtable.drawio.png" src="../_images/hashtable.drawio.png" style="width: 30%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 37.1 </span><span class="caption-text">Concurrent hashtable with per-bucket locking.</span><a class="headerlink" href="#fig-sync-readmostly-rcu-hashtable" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>For read-mostly workloads, where searches are much more frequent than insertions, deletions, or updates, we might want to use a rwlock on the hash buckets, but these have a lot of overhead for readers. Even ignoring the cost of the locks themselves, forcing all readers to wait so that a writer can have exclusive access may leave us with lots of “dead time” as depicted in <a class="reference internal" href="#fig-sync-readmostly-rcu-rwstall"><span class="std std-numref">Fig. 37.2</span></a>.</p>
<figure class="align-default" id="fig-sync-readmostly-rcu-rwstall">
<a class="reference internal image-reference" href="../_images/readerstall.drawio.png"><img alt="../_images/readerstall.drawio.png" src="../_images/readerstall.drawio.png" style="width: 60%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 37.2 </span><span class="caption-text">A single writer can block many readers with rwlocks.</span><a class="headerlink" href="#fig-sync-readmostly-rcu-rwstall" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Ideally, readers would never have to wait for writers, so that this wasted time could be eliminated, as depicted in <a class="reference internal" href="#fig-sync-readmostly-rcu-rwnostall"><span class="std std-numref">Fig. 37.3</span></a>.</p>
<figure class="align-default" id="fig-sync-readmostly-rcu-rwnostall">
<a class="reference internal image-reference" href="../_images/readernostall.drawio.png"><img alt="../_images/readernostall.drawio.png" src="../_images/readernostall.drawio.png" style="width: 60%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 37.3 </span><span class="caption-text">A writer does not wait for readers to finish, and does not block readers.</span><a class="headerlink" href="#fig-sync-readmostly-rcu-rwnostall" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>In <a class="reference internal" href="concurrency_bugs.html#cont-sync-concurrency-bugs-break-mutex"><span class="std std-numref">Section 36.3.4</span></a>, we mentioned non-blocking synchronization as a way to break the mutual exclusion condition, and noted that there were non-blocking implementations of linked lists. We could certainly use a non-blocking linked list in our concurrent hash table, which would eliminate the stalls in <a class="reference internal" href="#fig-sync-readmostly-rcu-rwstall"><span class="std std-numref">Fig. 37.2</span></a>, but this still introduces more overhead than we would like, even if the workload is entirely read-only. To see why, consider what happens if there is a concurrent lookup and delete operation on a linked list. We show this scenario in <a class="reference internal" href="#fig-sync-readmostly-rcu-linkedlist-nbs"><span class="std std-numref">Fig. 37.4</span></a>.</p>
<figure class="align-default" id="fig-sync-readmostly-rcu-linkedlist-nbs">
<a class="reference internal image-reference" href="../_images/linkedlist_nbs.drawio.png"><img alt="../_images/linkedlist_nbs.drawio.png" src="../_images/linkedlist_nbs.drawio.png" style="width: 75%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 37.4 </span><span class="caption-text">Concurrent read and removal of an element in a linked list.</span><a class="headerlink" href="#fig-sync-readmostly-rcu-linkedlist-nbs" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Here, a reader thread T1 is traversing the linked list and has obtained a pointer to node N (e.g., by reading the previous node’s <code class="docutils literal notranslate"><span class="pre">next</span></code> field). T1 still needs to read several fields from node N (e.g., the key, to see if it is the one it is searching for, and the value if the key matches, or the next pointer to continue the search if the key does not match). At some point after T1 has a pointer to N, a writer thread T2 deletes N from the linked list. Removal from the list can be done atomically by changing the previous node’s <code class="docutils literal notranslate"><span class="pre">next</span></code> field to point to the node that follows N (shown by the dotted line in the figure). However, T2 cannot reclaim the memory used by node N until it can guarantee that T1 no longer holds a pointer to it.</p>
<p><em>Reference counting</em> is the common solution to guarantee the continued existence of a node as long as a thread needs it. Each node includes an integer reference count, and each thread must atomically increment the reference count when it gets a pointer to the node, and atomically decrement the reference count when it is done with the node. A node that is removed from the linked list can be reclaimed when the removing thread holds the last reference to it. Thus, as T1 traverses the list, it must perform two atomic operations on <em>every</em> node that it visits just to guarantee that the node doesn’t disappear out from under it (see <a class="reference internal" href="#fig-sync-readmostly-rcu-linkedlist-nbs-refcount"><span class="std std-numref">Fig. 37.5</span></a>). Worse, all reader threads need to atomically change the reference counts, even if there aren’t any writers operating concurrently!
Atomic arithmetic operations are much more expensive than an ordinary addition or subtraction operation because they must modify memory (not a CPU register), and they limit the ability to hide the cost of memory access by re-ordering other instructions. As a result, reference counting can have a surprisingly high overhead.</p>
<figure class="align-default" id="fig-sync-readmostly-rcu-linkedlist-nbs-refcount">
<a class="reference internal image-reference" href="../_images/linkedlist_nbs_refcount.drawio.png"><img alt="../_images/linkedlist_nbs_refcount.drawio.png" src="../_images/linkedlist_nbs_refcount.drawio.png" style="width: 75%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 37.5 </span><span class="caption-text">Concurrent read and removal of an element in a linked list with reference counting.</span><a class="headerlink" href="#fig-sync-readmostly-rcu-linkedlist-nbs-refcount" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>RCU has the same problem of deferred deletion, but it avoids the use of reference counting, so that no extra work is imposed on readers. The tradeoff is that writers need to do more work, but this is reasonable since we are expecting a read-mostly workload.</p>
</section>
<section id="the-read-side">
<h3><span class="section-number">37.3.2. </span>The read-side<a class="headerlink" href="#the-read-side" title="Permalink to this headline">#</a></h3>
<p>The Linux RCU API requires programmers to mark the boundaries of a read-side critical section with <code class="docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code> and <code class="docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code> calls. Reader threads are not allowed to block in an RCU read-side critical section, and are not allowed to use any pointer to rcu-protected shared data outside of a read-side critical section. In spite of the names, these API calls do not actually lock anything. In a non-preemptible kernel build environment, they are simply empty macros that do nothing at all. For a pre-emptible kernel, the <code class="docutils literal notranslate"><span class="pre">rcu_read_lock()</span></code> call simply needs to disable preemption, while the <code class="docutils literal notranslate"><span class="pre">rcu_read_unlock()</span></code> call re-enables it. This ensures that readers can complete their critical sections without losing the CPU to any interfering threads. Even in a non-preemptible kernel, marking the boundaries of read-side critical sections with an API call is useful, as it helps programmers to reason about their code and avoid violating the requirements of read-side critical sections.</p>
</section>
<section id="the-write-side">
<h3><span class="section-number">37.3.3. </span>The write-side<a class="headerlink" href="#the-write-side" title="Permalink to this headline">#</a></h3>
<p>RCU writers can use any mechanism to synchronize with other writers, but typically an ordinary mutual exclusion lock is used, because updates are expected to be relatively infrequent and so contention on the writer lock is expected to be low. Writers carry out their updates in two phases:</p>
<ol class="simple">
<li><p>The <em>removal phase</em> may atomically remove items from a data structure. These removals may occur due to either updates or deletions from the data structure. In the case of an update, the removed item is replaced with a reference to a new version of the item. Note that the removal phase may also insert completely new items to the data structure, without removing anything, in which case the second phase is not needed.</p></li>
<li><p>The <em>reclamation phase</em> frees the memory used by the removed items.</p></li>
</ol>
<p>The removal phase runs concurrently with readers, so readers that are active in a read-side critical section during this phase might still be using the removed items. To avoid use-after-free bugs in the readers, a writer must wait for a <em>grace period</em> between the removal and reclamation phases, after which there is a guarantee that all readers that were active during the removal phase no longer hold references to these items. Any readers that start after the removal phase can’t possibly obtain a reference to the removed items, so we don’t need to consider them. We show an example of this split update approach in <a class="reference internal" href="#fig-sync-readmostly-rcu-splitupdate"><span class="std std-numref">Fig. 37.6</span></a>. Readers that are still active in their read-side critical section at the end of the removal phase are depicted with cross-hatches. The writer must wait until all of these pre-existing readers have left their read-side critical sections and can no longer make any references to the removed data. After this grace period, the writer can reclaim the memory allocated for the removed item. Readers that enter their read-side critical section during the grace period, or during the reclamation phase, do not need to be waited for.</p>
<figure class="align-default" id="fig-sync-readmostly-rcu-splitupdate">
<a class="reference internal image-reference" href="../_images/splitupdate.drawio.png"><img alt="../_images/splitupdate.drawio.png" src="../_images/splitupdate.drawio.png" style="width: 75%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 37.6 </span><span class="caption-text">Updates are split into removal and reclamation phases, separated by a grace period.</span><a class="headerlink" href="#fig-sync-readmostly-rcu-splitupdate" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>An example of the writer side for an RCU-protected data structure is shown in <a class="reference internal" href="#listing-sync-readmostly-rcu-updater"><span class="std std-numref">Listing 37.3</span></a>. In this example, we have a global pointer to shared <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">foo</span></code>, which consists of three fields. We also have a spinlock <code class="docutils literal notranslate"><span class="pre">foo_mutex</span></code> for writers, to ensure there is at most one update happening at any time. The writer thread calls <code class="docutils literal notranslate"><span class="pre">foo_update_a</span></code> to update the <code class="docutils literal notranslate"><span class="pre">a</span></code> field with a new value, <code class="docutils literal notranslate"><span class="pre">new_a</span></code>. In this function, we first allocate memory for a new copy of the structure (line 16, <code class="docutils literal notranslate"><span class="pre">kmalloc</span></code> is just the kernel version of the C library <code class="docutils literal notranslate"><span class="pre">malloc</span></code> function), then (under the protection of the writer lock) we make a copy of the current structure, update the <code class="docutils literal notranslate"><span class="pre">a</span></code> field, and make the new version of the structure visible to other threads by setting the global <code class="docutils literal notranslate"><span class="pre">shared_foo</span></code> pointer to the new copy (lines 17-21). At this point, the removal phase of the update is complete and we can release the writer lock (line 22). The writer must wait for a grace period before it can free the memory allocated to the old copy of the structure, which it does by calling the Linux <code class="docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code> function (line 25). Finally, the memory is freed (line 28) and the function returns.</p>
<div class="literal-block-wrapper docutils container" id="listing-sync-readmostly-rcu-updater">
<div class="code-block-caption"><span class="caption-number">Listing 37.3 </span><span class="caption-text">RCU update of a shared, global data structure.</span><a class="headerlink" href="#listing-sync-readmostly-rcu-updater" title="Permalink to this code">#</a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 2</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 3</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 5</span><span class="p">};</span><span class="w"></span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">foo_mutex</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 8</span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="o">*</span><span class="n">shared_foo</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="kt">void</span><span class="w"> </span><span class="nf">foo_update_a</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">new_a</span><span class="p">)</span><span class="w"></span>
<span class="linenos">11</span><span class="p">{</span><span class="w"></span>
<span class="linenos">12</span><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="o">*</span><span class="n">new_fp</span><span class="p">,</span><span class="w"> </span><span class="n">old_fp</span><span class="p">;</span><span class="w"></span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="w">    </span><span class="cm">/* 1. Removal phase */</span><span class="w"></span>
<span class="linenos">15</span><span class="w">    </span>
<span class="hll"><span class="linenos">16</span><span class="w">    </span><span class="n">new_fp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="p">),</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
</span><span class="hll"><span class="linenos">17</span><span class="w">    </span><span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo_mutex</span><span class="p">);</span><span class="w"></span>
</span><span class="hll"><span class="linenos">18</span><span class="w">    </span><span class="n">old_fp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared_foo</span><span class="p">;</span><span class="w"></span>
</span><span class="hll"><span class="linenos">19</span><span class="w">    </span><span class="o">*</span><span class="n">new_fp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">old_fp</span><span class="p">;</span><span class="w"></span>
</span><span class="hll"><span class="linenos">20</span><span class="w">    </span><span class="n">new_fp</span><span class="o">-&gt;</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_a</span><span class="p">;</span><span class="w"></span>
</span><span class="hll"><span class="linenos">21</span><span class="w">    </span><span class="n">shared_foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_fp</span><span class="p">;</span><span class="w"></span>
</span><span class="hll"><span class="linenos">22</span><span class="w">    </span><span class="n">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo_mutex</span><span class="p">);</span><span class="w"></span>
</span><span class="linenos">23</span><span class="w">    </span>
<span class="linenos">24</span><span class="w">    </span><span class="cm">/* Removal phase done. Wait for a grace period */</span><span class="w"></span>
<span class="hll"><span class="linenos">25</span><span class="w">    </span><span class="n">synchronize_rcu</span><span class="p">();</span><span class="w"></span>
</span><span class="linenos">26</span><span class="w">    </span>
<span class="hll"><span class="linenos">27</span><span class="w">    </span><span class="cm">/* 2. Reclamation phase */</span><span class="w"></span>
</span><span class="linenos">28</span><span class="w">    </span><span class="n">kfree</span><span class="p">(</span><span class="n">old_fp</span><span class="p">);</span><span class="w"></span>
<span class="linenos">29</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>The code in <a class="reference internal" href="#listing-sync-readmostly-rcu-updater"><span class="std std-numref">Listing 37.3</span></a> is a simplified example. It assumes that instructions cannot be re-ordered by either the compiler or the CPU at runtime; the full Linux RCU API includes operations to enforce the required ordering when reading or writing rcu-protected pointers. Now, let’s look at what happens in the <code class="docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code> function to ensure there are no dangerous read-reclaim races.</p>
</section>
<section id="handling-read-reclaim-races">
<h3><span class="section-number">37.3.4. </span>Handling read-reclaim races<a class="headerlink" href="#handling-read-reclaim-races" title="Permalink to this headline">#</a></h3>
<p>The challenge in handling read-reclaim races lies in detecting when a grace period has elapsed. We cannot use actual time to define a grace period, since we do not know how long readers will stay in a read-side critical section. We also don’t want the readers to do any extra work to help detect grace periods, as happens with reference counting, or at least keep the reader overhead to a bare minimum.</p>
<p>RCU uses <em>quiescent state based reclamation</em> (QSBR) <span id="id2">[<a class="reference internal" href="../misc/bib.html#id17" title="Thomas E. Hart, Paul E. McKenney, Angela Demke Brown, and Jonathan Walpole. Performance of memory reclamation for lockless synchronization. J. Parallel Distrib. Comput., 67(12):1270–1285, dec 2007. URL: https://doi.org/10.1016/j.jpdc.2007.04.010, doi:10.1016/j.jpdc.2007.04.010.">HMBW07</a>]</span> to detect grace periods and determine when it is safe to reclaim a removed item. We define a <em>quiescent state</em> for a thread T as a state in which T holds no references to rcu-protected shared data. We can then define a <em>grace period</em> as an interval in which every thread has entered at least one quiescent state, as shown in <a class="reference internal" href="#fig-sync-readmostly-rcu-qsbr"><span class="std std-numref">Fig. 37.7</span></a>. Essentially, this means that we do not need to be concerned with tracking <em>every</em> reference to shared data from <em>every</em> thread—we just need to track quiescent states.</p>
<figure class="align-default" id="fig-sync-readmostly-rcu-qsbr">
<a class="reference internal image-reference" href="../_images/qsbr.drawio.png"><img alt="../_images/qsbr.drawio.png" src="../_images/qsbr.drawio.png" style="width: 75%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 37.7 </span><span class="caption-text">Illustration of quiescent state based reclamation. Grace periods occur when every thread has gone through a quiescent state.</span><a class="headerlink" href="#fig-sync-readmostly-rcu-qsbr" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>But how can we know that a thread is in a quiescent state if we are not keeping track of its references to shared data? Recall that reader threads are not allowed to use any pointer to rcu-protected data outside of a read-side critical section. So, whenever a reader thread is not in a read-side critical section, it is in a quiescent state. Recall also that readers in a read-side critical section cannot block or be preempted. These properties are a great help in detecting grace periods in an operating system kernel. First, any thread that is not running on a CPU at the end of a writer’s removal phase must already be in a quiescent state and we don’t need to consider them any further. Second, for all threads that are running on a CPU at the end of the writer’s removal phase, they must be in a quiescent state when a context switch occurs (i.e., context switches, whether due to blocking or preemption, are not allowed in a read-side critical section). Thus, the <code class="docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code> function only needs to wait until all other CPUs perform a context switch to be sure that a grace period has elapsed. Conceptually, this can be done by having the writer thread run some code in the <code class="docutils literal notranslate"><span class="pre">synchronize_rcu()</span></code> function on every CPU. If the writer is able to run on every CPU, then a context switch must have occurred on every CPU, and every reader thread has entered at least one quiescent state. A sketch of the code for this “toy” implementation is shown in <a class="reference internal" href="#listing-sync-readmostly-synchronize-rcu"><span class="std std-numref">Listing 37.4</span></a>.</p>
<div class="literal-block-wrapper docutils container" id="listing-sync-readmostly-synchronize-rcu">
<div class="code-block-caption"><span class="caption-number">Listing 37.4 </span><span class="caption-text">Toy implementation of function to wait for a grace period.</span><a class="headerlink" href="#listing-sync-readmostly-synchronize-rcu" title="Permalink to this code">#</a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="kt">void</span><span class="w"> </span><span class="nf">synchronize_rcu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="linenos">2</span><span class="p">{</span><span class="w"></span>
<span class="linenos">3</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cpu</span><span class="p">;</span><span class="w"></span>
<span class="linenos">4</span>
<span class="linenos">5</span><span class="w">    </span><span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span><span class="w"></span>
<span class="linenos">6</span><span class="w">        </span><span class="n">run_on</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span><span class="w"></span>
<span class="linenos">7</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>Of course, there are many details of a robust, scalable, RCU implementation that we have glossed over in this quick introduction. Interested readers are encouraged to refer to the Linux kernel documentation and source code.</p>
<p>The use of RCU in Linux has been growing steadily, as shown in <a class="reference internal" href="#fig-sync-readmostly-rcu-usage"><span class="std std-numref">Fig. 37.8</span></a>, however, it is not a suitable replacement for every synchronization need. Uses of the lock APIs in Linux still far outnumber RCU (see <a class="reference internal" href="#fig-sync-readmostly-rcu-usage-vs-locks"><span class="std std-numref">Fig. 37.9</span></a>).</p>
<figure class="align-default" id="fig-sync-readmostly-rcu-usage">
<a class="reference internal image-reference" href="../_images/linux-RCU.png"><img alt="../_images/linux-RCU.png" src="../_images/linux-RCU.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 37.8 </span><span class="caption-text">Growth of RCU usage in the Linux kernel (from <a class="reference external" href="http://www.rdrop.com/~paulmck/RCU/linuxusage.html">http://www.rdrop.com/~paulmck/RCU/linuxusage.html</a>, April 25, 2023)</span><a class="headerlink" href="#fig-sync-readmostly-rcu-usage" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<figure class="align-default" id="fig-sync-readmostly-rcu-usage-vs-locks">
<a class="reference internal image-reference" href="../_images/linux-RCUlock.png"><img alt="../_images/linux-RCUlock.png" src="../_images/linux-RCUlock.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 37.9 </span><span class="caption-text">Linux RCU and lock usage (from <a class="reference external" href="http://www.rdrop.com/~paulmck/RCU/linuxusage.html">http://www.rdrop.com/~paulmck/RCU/linuxusage.html</a>, April 25, 2023)</span><a class="headerlink" href="#fig-sync-readmostly-rcu-usage-vs-locks" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
</section>
</section>


<script type="application/vnd.jupyter.widget-state+json">
{"state": {"1608c18fd9a647cb8fc60f109d25a366": {"model_module": "@jupyter-widgets/output", "model_module_version": "1.0.0", "model_name": "OutputModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/output", "_model_module_version": "1.0.0", "_model_name": "OutputModel", "_view_count": null, "_view_module": "@jupyter-widgets/output", "_view_module_version": "1.0.0", "_view_name": "OutputView", "layout": "IPY_MODEL_8c15612c19d14f208b868f6ab9cf68b1", "msg_id": "", "outputs": [{"name": "stdout", "output_type": "stream", "text": "$ [[ -d mydir ]] && rm -rf mydir\r\n$     #\r\n$ "}]}}, "8c15612c19d14f208b868f6ab9cf68b1": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": "1px solid black", "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": "100%", "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": "scroll", "padding": null, "right": null, "top": null, "visibility": null, "width": null}}}, "version_major": 2, "version_minor": 0}
</script>


    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./sync"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="concurrency_bugs.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">36. </span>Common Concurrency Bugs</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="hardware_challenges.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">38. </span>Challenges of Modern Hardware</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By (see contributing chapter book)<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>