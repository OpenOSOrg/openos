
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>38. Virtualization and Cloud computing &#8212; Introduction to Operating Systems</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="39. Other OS structures" href="../intro/other.html" />
    <link rel="prev" title="37. Overview of other topics" href="../misc/OtherInro.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Introduction to Operating Systems</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro/pref.html">
                    Preface
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/intro.html">
   1. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/purpose.html">
   2. Purpose of operating systems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/structure.html">
   3. Operating System Structure &amp; Unix/Linux
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/abstractions.html">
   4. Operating System Abstractions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/tools.html">
   5. Tools
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Virtual Processor
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../scheduling/intro.html">
   6. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../scheduling/process.html">
   7. Virtualizing a CPU
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../scheduling/scheduling.html">
   8. Scheduling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../scheduling/real_sched.html">
   9. A Look at the Linux Scheduler
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  File Systems
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/intro.html">
   10. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/interface.html">
   11. File System Abstraction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/diskhw.html">
   12. A bit about Disks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/disklayout.html">
   13. File System Layout
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/dl_track_used.html">
   14. Disk Layout:Tracking Used Space
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/dl_track_free.html">
   15. Disk Layout:Tracking Free Space
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/dl_name.html">
   16. Disk Layout:Implementing Name Space
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/dl_failures.html">
   17. Disk Layout:Dealing with Failures
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/dl_ex_exx.html">
   18. Disk Layout:Examples of Real World File Systems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/kernelimp.html">
   19. Kernel implementation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Virtual Memory
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/intro.html">
   20. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/phys-and-seg.html">
   21. Memory management before paged virtual memory
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/virt-paging.html">
   22. Paging
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/page-tables.html">
   23. Page Tables
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/reclamation.html">
   24. Memory reclaiming algorithms.
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/page-size.html">
   25. Page Sizes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/misc.html">
   26. Other topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/buffer-cache.html">
   27. Buffer Cache
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/pagefaults.html">
   28. Memory Management Dynamics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/realworld.html">
   29. Memory management in the real world
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/concl.html">
   30. Conclusion
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Concurrency
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/sync.html">
   31. Intro Concurrency Synchronization and Deadlock
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/sharing.html">
   32. Cooperating Processes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/locking.html">
   33. Synchronization Primitives
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/deadlock.html">
   34. Deadlocks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/hardware_challenges.html">
   35. Challenges of Modern Hardware
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/linux_locking.html">
   36. Locking in the Linux Kernel
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Other Topics
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../misc/OtherInro.html">
   37. Overview of other topics
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   38. Virtualization and Cloud computing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/other.html">
   39. Other OS structures
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Appendices
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../misc/howto.html">
   40. How to read this book
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../contributing/Contributing.html">
   41. Contributing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../misc/bib.html">
   42. Bibliography
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/okrieg/openos/main?urlpath=lab/tree/content/virt/virt.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
      <li>
        <a href="https://jupyterhub-redhat-ods-applications.apps.buaws-dev.idu6.p1.openshiftapps.com/hub/user-redirect/git-pull?repo=https%3A//github.com/okrieg/openos&urlpath=lab/tree/openos/content/virt/virt.ipynb&branch=main"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on JupyterHub"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_jupyterhub.svg">
  </span>
<span class="headerbtn__text-container">JupyterHub</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/okrieg/openos"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/okrieg/openos/issues/new?title=Issue%20on%20page%20%2Fvirt/virt.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/okrieg/openos/edit/main/content/virt/virt.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="headerbtn__text-container">suggest edit</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/virt/virt.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hardware-virtualization">
   38.1. Hardware virtualization
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     38.1.1. Hardware Virtualization
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#implementing-hardware-virtualization">
   38.2. Implementing Hardware Virtualization
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#software-emulation">
     38.2.1. Software emulation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#emulation-plus-binary-translation">
     38.2.2. Emulation plus binary translation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#trap-and-emulate">
     38.2.3. Trap and Emulate
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#virtualized-memory">
   38.3. Virtualized memory
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#review-questions">
     38.3.1. Review questions
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#virtualized-i-o-devices">
   38.4. Virtualized I/O Devices
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hosted-and-bare-metal-hypervisors">
   38.5. Hosted and “bare-metal” hypervisors
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#non-virtualizable-cpus">
   38.6. Non-Virtualizable CPUs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#paravirtualized-i-o-devices">
   38.7. Paravirtualized I/O Devices
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#linux-containers-and-docker">
   38.8. Linux Containers and Docker
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#answers-to-review-questions">
     38.8.1. Answers to Review Questions
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#containers">
   38.9. Containers
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cloud-computing">
   38.10. Cloud Computing
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Virtualization and Cloud computing</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hardware-virtualization">
   38.1. Hardware virtualization
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     38.1.1. Hardware Virtualization
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#implementing-hardware-virtualization">
   38.2. Implementing Hardware Virtualization
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#software-emulation">
     38.2.1. Software emulation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#emulation-plus-binary-translation">
     38.2.2. Emulation plus binary translation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#trap-and-emulate">
     38.2.3. Trap and Emulate
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#virtualized-memory">
   38.3. Virtualized memory
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#review-questions">
     38.3.1. Review questions
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#virtualized-i-o-devices">
   38.4. Virtualized I/O Devices
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hosted-and-bare-metal-hypervisors">
   38.5. Hosted and “bare-metal” hypervisors
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#non-virtualizable-cpus">
   38.6. Non-Virtualizable CPUs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#paravirtualized-i-o-devices">
   38.7. Paravirtualized I/O Devices
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#linux-containers-and-docker">
   38.8. Linux Containers and Docker
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#answers-to-review-questions">
     38.8.1. Answers to Review Questions
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#containers">
   38.9. Containers
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cloud-computing">
   38.10. Cloud Computing
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This portion of the book is under construction, not ready to be read</p>
</div>
<section class="tex2jax_ignore mathjax_ignore" id="virtualization-and-cloud-computing">
<span id="cont-virt"></span><h1><span class="section-number">38. </span>Virtualization and Cloud computing<a class="headerlink" href="#virtualization-and-cloud-computing" title="Permalink to this headline">#</a></h1>
<section id="hardware-virtualization">
<h2><span class="section-number">38.1. </span>Hardware virtualization<a class="headerlink" href="#hardware-virtualization" title="Permalink to this headline">#</a></h2>
<section id="id1">
<h3><span class="section-number">38.1.1. </span>Hardware Virtualization<a class="headerlink" href="#id1" title="Permalink to this headline">#</a></h3>
<p>Topics covered in this chapter include:</p>
<ul class="simple">
<li><p>Applications of virtualization, including server consolidation</p></li>
<li><p>Software emulation, full binary translation, and classical
virtualization</p></li>
<li><p>Kernel binary translation, hardware virtualization, and
paravirtualization</p></li>
<li><p>Virtual machine migration</p></li>
<li><p>Hosted vs. “bare-metal” hypervisors</p></li>
<li><p>Containers and Docker (even though they don’t use HW virtualization)</p></li>
</ul>
<p>Hardware virtualization is a technique that allows multiple virtual
machines (VMs) to run on the same physical machine, using either pure
software or a combination of hardware and software techniques.</p>
<p>Previous chapters have described the differences between
<em>threads</em>—separate flows of control sharing (almost) all resources
such as memory and file descriptors—and <em>processes</em>, which are
isolated from each other by the operating system, requiring the use of
files, pipes, or similar mechanisms to communicate between two
processes. A virtual machine is similar to a process, but is designed to
run a full operating system and its applications, rather than a single
program; communication between VMs is like that between real machines,
and must take place over (possibly emulated) networks.</p>
<p>A virtual machine requires a much different interface—while a process
runs in unprivileged mode, performing I/O and memory management
operations by issuing system calls to the OS kernel, an operating system
runs in supervisor mode and uses special instructions and other hardware
mechanisms to perform its operations. In a virtual machine, as shown in
<a class="reference external" href="#fig:vma:0">[fig:vma:0]</a>{reference-type=”autoref”
reference=”fig:vma:0”}, these mechanisms are performed by the
<em>hypervisor</em> <a class="footnote-reference brackets" href="#id10" id="id2">1</a> which sits “underneath” the operating system.</p>
<p><img alt="Virtual machine architecture" src="virt/figures/virt-mach-architecture" />{#fig:vma:0 width=”90%”}</p>
<p>Running multiple operating system instances on the same physical
hardware serves a number of purposes:</p>
<p><strong>Running multiple operating systems:</strong> Many applications are tied to a
specific OS or even OS version; by using virtual machines it is possible
to run instances of these other operating systems and make these
applications availabe to a user without requiring extra hardware. (As an
example, the laptop I am typing on runs Apple’s OS X, but I have a
virtual machine running Ubuntu Linux for Linux development.)</p>
<p><strong>Multiple Configurations:</strong> Even applications which run on the same
operating system may need to run on different machines, rather than just
in separate processes. This may be because they require different,
incompatible versions of system libraries, or different configuration
options. In some cases (e.g. running an old and new version of the same
application) they may need different versions of the same configuration
files.</p>
<p>Supporting multiple configurations is frequently called <em>server
consolidation</em>, as in the past an enterprise may have needed to use
multiple physical machines to provide these configurations. Frequently
the load on each service or configuration was much less than what could
be handled by a single machine, and many of these services can instead
be deployed as virtual machines on a single physical system.</p>
<p><strong>Security:</strong> Many applications (e.g. webservers, databases) require
administrative privileges (e.g. root on Unix) for configuration. In the
past these applications were typically considered infrastructure
services, maintained and configured by system administrators at the
request of users. However in many recent cases (e.g. Amazon’s Elastic
Compute Cloud) the customer is expected to perform all configuration and
management, and multiple untrusted customers may share the same physical
hardware. Instead of being provided an unprivileged login on a shared
machine, each customer is given a virtual machine which they can
configure as they wish, with full root or administrative privileges,
without posing a threat to customers on other virtual machines.</p>
<aside class="sidebar">
<p>12 Operating system <em>containers</em>, such as those used by Docker, provide
many of the advantages of virtual machines while using a single
operating system. Each container is a set of processes with a
<em>namespace</em> of process IDs and network connections, and a separate file
system tree, and (barring misconfiguration or kernel bugs) is unable to
access resources belonging to other containers or to the host OS.</p>
</aside>
<p>These uses for virtual machines are artifacts of how applications and
operating systems have evolved, and a perfectly-designed OS would no
doubt provide the security and manageability benefits described above
using operating system-level protections. (This would of course
eliminate the need to use any other less perfect operating system.)
Virtual machines hold another security advantage, however: they have a
smaller <em>attack surface</em> than general-purpose operating systems.
Operating systems are very large, with millions of lines of code.<a class="footnote-reference brackets" href="#id11" id="id3">2</a> A
<em>hypervisor</em>, the piece of software responsible for managing virtual
machines, is typically far smaller in comparison, and has only a small
number of external interfaces. In theory fewer lines of code (espcially
the security-critical code which validates user inputs) means fewer bugs
and thus fewer opportunities for security exploits; experience to date
seems to support this theory.</p>
</section>
</section>
<section id="implementing-hardware-virtualization">
<h2><span class="section-number">38.2. </span>Implementing Hardware Virtualization<a class="headerlink" href="#implementing-hardware-virtualization" title="Permalink to this headline">#</a></h2>
<p>If you are used to running VirtualBox or VMware on your laptop, it may
seem like it’s just another program, maybe using more memory and CPU
than most. But it isn’t. To understand why, consider trying to run Linux
(the “guest” operating system) on top of a “host” operating system, e.g.
Windows. The linux kernel is an executable file, typically found in
<code class="docutils literal notranslate"><span class="pre">/boot/vmlinux</span></code>, and could be readily translated into a Windows
executable. However if you tried to do this<a class="footnote-reference brackets" href="#id12" id="id4">3</a> it would crash
immediately. Some of the reasons an operating system kernel cannot run
as a process are:</p>
<p><strong>Privileged instructions:</strong> One of the first things the kernel does on
startup is to initialize the virtual memory system, mapping virtual
addresses to physical addresses. This configuration requires
privileged-mode instructions, which are inaccessible to user-mode
applications, as they could be used to bypass operating system
protections. The first such instruction executed by the guest OS would
cause an exception, killing the process.</p>
<p><strong>Interference:</strong> The problem isn’t just that the guest OS won’t be
allowed to modify virtual address mappings. If it actually could modify
these mappings, then the underlying host operating system would almost
certainly crash, as it assumes that it has complete control over them.
The CPU only has a single address translation mechanism, and if two
operating systems are going to make use of it, they must either
deliberately share access, or it must be virtualized before being used
by one or both OS.</p>
<p><strong>Security:</strong> Secure isolation between virtual machines, including
memory protection, is at least as important as isolation between
processes in a normal operating system. But if a guest operating system
has direct access to the CPU address translation mechanisms it can
easily access physical memory allocated to another virtual machine (or
to the host OS itself), bypassing any security mechanisms.</p>
<p><strong>I/O:</strong> A process running under Linux or Windows uses <em>system calls</em>
such as <strong>open</strong> and <strong>read</strong> to access <em>files</em>. In contrast, an
operating system uses <em>drivers</em> to access <em>physical devices</em>.</p>
<p>In the remainder of this chapter we discuss the following approaches to
supporting virtual machines, arranged (roughly) in increasing order of
both complexity and performance:</p>
<ul class="simple">
<li><p>Software emulation.</p></li>
<li><p>Emulation with binary translation.</p></li>
<li><p>Classical (direct execution + trap-and-emulate) virtualization</p></li>
<li><p>Direct execution + binary translation</p></li>
<li><p>Hardware-assisted virtualization</p></li>
<li><p>Paravirtualization.</p></li>
</ul>
<section id="software-emulation">
<h3><span class="section-number">38.2.1. </span>Software emulation<a class="headerlink" href="#software-emulation" title="Permalink to this headline">#</a></h3>
<p>The most straightforward way to run a virtual machine is to emulate it
entirely in software: in other words, to write a program that behaves
exactly like the CPU, memory, and I/O devices of the real machine. The
idea is simple: given a complete description of how the CPU behaves,
create variables for the registers and a big array for memory, and write
a program that repeatedly fetches instructions from the memory array,
decodes them, and emulates their operation, much like the sample code in
<a class="reference external" href="#fig:vma:1">[fig:vma:1]</a>{reference-type=”autoref”
reference=”fig:vma:1”}.</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">memory</span><span class="p">[</span><span class="n">EMULATED_MEM_SIZE</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">R2</span><span class="p">,</span><span class="w"> </span><span class="n">R3</span><span class="p">,</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">PC</span><span class="p">,</span><span class="w"> </span><span class="n">SP</span><span class="p">,</span><span class="w"> </span><span class="n">CR1</span><span class="p">,</span><span class="w"> </span><span class="n">CR2</span><span class="p">,</span><span class="w"> </span><span class="n">CR3</span><span class="p">,</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">S</span><span class="p">;</span><span class="w"> </span><span class="cm">/* supervisor mode */</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">       </span><span class="n">instr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory</span><span class="p">[</span><span class="n">PC</span><span class="p">]</span><span class="w"></span>
<span class="w">       </span><span class="n">PC</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">instr</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="no">instr</span><span class="p">)</span><span class="w"> </span><span class="no">in</span><span class="p">:</span><span class="w"></span>
<span class="w">         </span><span class="s">&quot;MOV R1 -&gt; R2&quot;</span><span class="o">:</span><span class="w"></span>
<span class="w">           </span><span class="n">R2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R1</span><span class="w"></span>
<span class="w">         </span><span class="k">case</span><span class="w"> </span><span class="s">&quot;JMP &lt;arg&gt;&quot;</span><span class="p">:</span><span class="w"></span>
<span class="w">           </span><span class="n">PC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="n">arg</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">         </span><span class="k">case</span><span class="w"> </span><span class="s">&quot;STORE Rx, &lt;addr&gt;&quot;</span><span class="p">:</span><span class="w"></span>
<span class="w">          </span><span class="o">&lt;</span><span class="n">paddr</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MMU_translate</span><span class="p">[</span><span class="o">&lt;</span><span class="n">addr</span><span class="o">&gt;</span><span class="p">]</span><span class="w"></span>
<span class="w">                      </span><span class="o">-</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">error</span><span class="o">:</span><span class="w"> </span><span class="n">emulate</span><span class="w"> </span><span class="n">page</span><span class="w"> </span><span class="n">fault</span><span class="w"></span>
<span class="w">           </span><span class="k">if</span><span class="w"> </span><span class="o">&lt;</span><span class="n">paddr</span><span class="o">&gt;</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">real</span><span class="w"> </span><span class="n">memory</span><span class="o">:</span><span class="w"></span>
<span class="w">             </span><span class="n">memory</span><span class="p">[</span><span class="n">paddr</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rx</span><span class="w"></span>
<span class="w">           </span><span class="k">else</span><span class="w"></span>
<span class="w">             </span><span class="n">simulate_IO_access</span><span class="p">(</span><span class="n">Write</span><span class="p">,</span><span class="w"> </span><span class="n">paddr</span><span class="p">,</span><span class="w"> </span><span class="n">Rx</span><span class="p">)</span><span class="w"></span>
<span class="w">         </span><span class="p">....</span><span class="w"> </span><span class="n">Etc</span><span class="p">.</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="o">~</span><span class="mi">1000</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">instructions</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<aside class="sidebar">
<p>The Java Virtual Machine (JVM) executes bytecode instructions, and can
be considered a sort of CPU. Almost all JVMs are based on software
emulation, typically with additional performance optimizations.</p>
</aside>
<p>Full software emulation is simple conceptually, although in practice the
list of instructions to implement can get long (over 1000 on modern x86
CPUs) and complex. It has one major advantage, portability: once the
code to emulate a specific CPU is written, it can be compiled and run on
almost any host. This is especially useful in embedded development,
where it is often necessary to develop and test software before the CPU
(or at least the system incorporating that CPU) is ready to use.</p>
<p>The primary disadvantage is performance—full software emulation is
slow. It can be hundreds of times slower than native execution, making
it unsuited for all but a few applications.</p>
</section>
<section id="emulation-plus-binary-translation">
<h3><span class="section-number">38.2.2. </span>Emulation plus binary translation<a class="headerlink" href="#emulation-plus-binary-translation" title="Permalink to this headline">#</a></h3>
<aside class="sidebar">
<p>Other software systems which use binary translation techniques include:</p>
<p><strong>JVMs:</strong> Almost all Java implementations use JIT compiling for
performance.</p>
<p><strong>Javascript:</strong> Recent browsers (Safari, Firefox, and others) use
just-in-time compilation to improve Javascript performance.</p>
<p><strong>Apple Rosetta:</strong> This allowed Intel-based Macintosh computers to
execute programs compiled for PowerPC.</p>
</aside>
<p>Software interpreters can be sped up by what Java developers call Just
In Time (JIT) compilation, and which CPU emulator developers call Binary
Translation. The idea is to translate commonly-used fragments of code
into actual machine code, which can usually run far faster than pure
emulation. (In part, it eliminates the software-implemented instruction
fetch and decode for each instruction, which is a significant overhead.)
An example can be seen in
<a class="reference external" href="#fig:vma:2">[fig:vma:2]</a>{reference-type=”autoref”
reference=”fig:vma:2”}.</p>
<p>The following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>       <span class="n">ADD</span>  <span class="n">R1</span><span class="o">+</span><span class="n">R2</span> <span class="o">-&gt;</span> <span class="n">R2</span>
       <span class="n">ADD</span>  <span class="n">R2</span><span class="o">+</span><span class="n">R3</span> <span class="o">-&gt;</span> <span class="n">R3</span>
       <span class="n">MUL</span>  <span class="mi">2</span><span class="p">,</span><span class="n">R3</span>  <span class="o">-&gt;</span> <span class="n">R3</span>
</pre></div>
</div>
<p>might be translated into the following fragment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>       <span class="n">LOAD</span> <span class="n">Rx</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="n">emulated_R1</span>     
       <span class="n">LOAD</span> <span class="n">Ry</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="n">emulated_R2</span>
       <span class="n">LOAD</span> <span class="n">Rz</span> <span class="o">&lt;-</span> <span class="o">&amp;</span><span class="n">emulated_R3</span>
       <span class="n">ADD</span> <span class="n">Rx</span><span class="p">,</span><span class="n">Ry</span> <span class="o">-&gt;</span> <span class="n">Ry</span>             
       <span class="n">ADD</span> <span class="n">Ry</span><span class="p">,</span><span class="n">Rz</span> <span class="o">-&gt;</span> <span class="n">Rz</span>
       <span class="n">MUL</span> <span class="mi">2</span><span class="p">,</span><span class="n">Rz</span>  <span class="o">-&gt;</span> <span class="n">Rz</span>
       <span class="n">STORE</span> <span class="n">Ry</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">emulated_R2</span>    
       <span class="n">STORE</span> <span class="n">Rz</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">emulated_R3</span>
       <span class="n">RET</span>                          
</pre></div>
</div>
<p>In other words, the following occurs when a section of binary-translated
code is executed:</p>
<ol class="simple">
<li><p>The real CPU registers are loaded from the virtual (i.e., software-emulated) registers</p></li>
<li><p>The translated instructions are executed</p></li>
<li><p>The virtual CPU state is updated with results from the real CPU</p></li>
</ol>
<p>In most cases the translator will produce more than one instruction per
emulated instruction. Memory accesses are particularly tricky, as the
generated code must emulate address translation performed by the MMU,
and then check to see whether the resulting address is I/O or RAM before
performing the operation. In practice it may be possible to arrange
emulator memory (using e.g. the <code class="docutils literal notranslate"><span class="pre">mmap</span></code> system call) so that most memory
accesses can be performed directly; in this case the overhead for most
memory accesses can be reduced to a few instructions which check that an
access falls within this typical range.</p>
</section>
<section id="trap-and-emulate">
<h3><span class="section-number">38.2.3. </span>Trap and Emulate<a class="headerlink" href="#trap-and-emulate" title="Permalink to this headline">#</a></h3>
<p>Even with binary translation, software emulation is still slow—even
the best binary translation systems incur a slowdown of 3x to 10x
compared to running directly on the same hardware. This is much better
than unoptimized software emulation, and may be the best that can be
done when emulating one CPU on top of a CPU running a different
instruction set. (e.g. running iPhone or Android applications on an
Intel-based laptop or desktop, or the Rosetta emulator which Apple used
to allow PowerPC applications to run seamlessly on early Intel-based
Macintosh systems.)</p>
<p>However In many other cases—such as VirtualBox running on my
laptop—the CPU emulated by the virtual machine is the same as the
real, physical CPU. In this case we can improve performance greatly by
using <em>direct execution</em> when possible: executing instructions directly
on the physical CPU. The only reason we were emulating instructions in
the first place was because the host OS could not allow a virtual
machine to directly execute certain privileged instructions, so the goal
here is to emulate only these privileged instructions while directly
executing all others.</p>
<p>This can be done<a class="footnote-reference brackets" href="#id13" id="id5">4</a> using a strategy that can be called
<em>trap-and-emulate</em>. The guest OS is executed directly in user mode; when
it executes a privileged instruction it causes an exception which is
handled by a specialized OS called a <em>hypervisor</em> or <em>virtual machine
monitor</em>. The hypervisor loads the user-visible CPU registers into the
software CPU emulation, runs it for a single instruction, and then
returns back to direct execution.</p>
<p>It is interesting to compare a hypervisor running a guest OS (and guest
applications) with a traditional operating system running multiple
processes. A normal OS virtualizes CPU, memory, and other resources to
provide a virtual machine abstraction to each process: each process sees
its own memory space and a CPU which can execute user-mode instructions
and a special system call instruction. A hypervisor, in contrast,
performs a similar task of virtualizing memory and CPU, but provides a
virtual machine abstraction which is identical to that of the hardware
itself.</p>
<p><img alt="Trap-and-emulate virtualization" src="images/virt/virtual-mach-3.png" />{#fig:vma:3 width=”90%”}</p>
<p><a class="reference external" href="#fig:vma:3">[fig:vma:3]</a>{reference-type=”autoref”
reference=”fig:vma:3”} shows a representation of this trap-and-emulate
process. It allows almost all instructions to run directly, at native
hardware speed, while the specific instructions which need to be
executed in privileged mode (a tiny fraction of all instructions) are
emulated. This form of virtualization was originally developed by IBM in
the late 60s and early 70s for mainframes, where it continues to be
used.</p>
<p>But how does a hypervisor handle exceptions? An operating system relies
heavily on exceptions; in fact, just about everything an OS does is part
of some exception handler, whether that exception is a system call, a
page fault, or a timer or I/O device interrupt. Since the guest OS runs
in user mode, exceptions such as system calls or page faults generated
by guest applications will be delivered to the hypervisor rather than
the guest OS. The solution is for the hypervisor to just emulate the
real CPU operation:</p>
<ol class="simple">
<li><p>Set the emulated supervisor bit to 1</p></li>
<li><p>(with the emulated CPU) Handle user/supervisor stack switch, pushing
registers, and all the other exception-handling mechanisms that take up
so many pages in the CPU reference manuals.</p></li>
<li><p>Return to user mode, load user-visible registers from the emulated CPU, and call the guest OS exception handler.</p></li>
<li><p>When the guest exception handler returns, set the emulated supervisor
bit to 0, restore user registers from the kernel stack, switch to user
stack, then jump back to direct execution at the instruction where the
exception occurred<a class="footnote-reference brackets" href="#id14" id="id6">5</a>.</p></li>
</ol>
<p>How does it know where to find that exception handler? The hardware CPU
locates exception handlers via one or more control registers which point
to interrupt descriptors which are located in memory. (e.g in
Intel-compatible CPUS the <code class="docutils literal notranslate"><span class="pre">IDTR</span></code> register, which points to the
<em>interrupt descriptor table</em>) These registers may only be accessed in
supervisor mode, so the hypervisor is able to virtualize access to these
registers and maintain a separate emulated copy for each virtual
machine. The real hardware register points to the hypervisor exception
handler table, and when a hypervisor exception handler determines that
an exception should be forwarded to the guest operating system it looks
in the table pointed to by the emulated register to find the guest OS
exception handler.</p>
</section>
</section>
<section id="virtualized-memory">
<h2><span class="section-number">38.3. </span>Virtualized memory<a class="headerlink" href="#virtualized-memory" title="Permalink to this headline">#</a></h2>
<p>In a full software emulation, guest virtual addresses were translated
into accesses to “fake” physical memory, e.g. the <code class="docutils literal notranslate"><span class="pre">memory[ ]</span></code> array in
the example code. However, with trap-and-emulate virtualization, guest
applications and most OS code execute directly on the CPU, and virtual
addresses are translated to physical addresses in hardware, by the TLB
and page tables. This is a problem, because to run multiple virtual
machines on a single host, the hypervisor must be able to prevent each
from accessing physical memory assigned to the other. Further
complicating things, in many cases each guest OS expects physical memory
to be in the same place, typically starting at physical address 0. This
requires two levels of address translation to get from virtual addresses
(used by the guest applications and OS) to real physical memory:</p>
<ol class="simple">
<li><p>Virtual address to “fake” physical address: this translation is
maintained by the guest OS</p></li>
<li><p>“Fake” physical address to real physical address: this translation is
maintained by the hypervisor</p></li>
</ol>
<p>How does this work on a CPU that only supports one level of
virtual-to-physical address translation? By having the hypervisor
maintain the real page tables (the ones pointed to by the real CR3) and
making sure these tables contain the full virtual <span class="math notranslate nohighlight">\(\rightarrow\)</span> fake
physical <span class="math notranslate nohighlight">\(\rightarrow\)</span> real physical translation. This requires two page
tables: one pointed to by the emulated CR3 and used by the guest, and
one “shadow” table that the real CR3 points to. When a page fault occurs
the hypervisor page fault handler uses the following logic:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    If faulting address is in guest page table:
      1. Look up virtual-to-fake-physical (guest page table) and 
             fake physical-to-real-physical (hypervisor) mappings
      2. Install virtual $\rightarrow$  real physical mapping in 
             shadow page table
      3. Return 
    else (not in guest page table):
      1. invoke guest OS page fault handler
</pre></div>
</div>
<section id="review-questions">
<h3><span class="section-number">38.3.1. </span>Review questions<a class="headerlink" href="#review-questions" title="Permalink to this headline">#</a></h3>
</section>
</section>
<section id="virtualized-i-o-devices">
<h2><span class="section-number">38.4. </span>Virtualized I/O Devices<a class="headerlink" href="#virtualized-i-o-devices" title="Permalink to this headline">#</a></h2>
<p>Memory-mapped I/O devices are straightforward to emulate in a
trap-and-emulate system. When the guest OS maps the physical memory
addresses of emulated device registers, the hypervisor leaves the
corresponding pages unmapped in the shadow table, so that all read and
write accesses will result in a page fault. The hypervisor page fault
handler handles faults on these pages specially, calling code that
emulates reading from or writing to the emulated I/O device.</p>
</section>
<section id="hosted-and-bare-metal-hypervisors">
<h2><span class="section-number">38.5. </span>Hosted and “bare-metal” hypervisors<a class="headerlink" href="#hosted-and-bare-metal-hypervisors" title="Permalink to this headline">#</a></h2>
<p>In <a class="reference external" href="#fig:vma:5">[fig:vma:5]</a>{reference-type=”autoref”
reference=”fig:vma:5”} you can see how this works together. Exceptions
from user applications (page faults, system calls, etc.) are handled by
the hypervisor, which in most cases passes them to the guest OS.
Interrupts from I/O devices are passed to drivers in the hypervisor,
which may in turn decide that it’s time for a virtual hardware device to
send an interrupt to a guest OS.</p>
<p><img alt="&quot;Type 1&quot; Hypervisor --- no host OS." src="images/virt/virt-mach-fig5.png" />{#fig:vma:5 height=”8\baselineskip”}</p>
<p>This image describes server systems (like VMware ESX), where the machine
boots the hypervisor instead of a regular OS, and does nothing but run
virtual machines. But what about a “hosted” system like VirtualBox or
VMware Workstation? In particular, how does it run “on top of” a host
OS?</p>
<p>The short answer is, it doesn’t. When you install VirtualBox it installs
a set of drivers, which (like normal hardware drivers) run as part of
the kernel, in supervisor mode. When a virtual machine starts running,
these drivers insert themselves under the host operating system,
“stealing” exceptions such as page faults and system calls whenever a
virtual machine is executing, and forwarding them to the hypervisor.
Running on the same system as a host operating system has its
advantages, though, as the host OS has drivers for all of its hardware,
a file system, display, and other useful interfaces. A hosted hypervisor
can take advantage of this, passing I/O requests back to the host OS
(via a rather complicated route) to be handled through these standard
interfaces, rather than requiring its own drivers for any hardware it
uses <a class="footnote-reference brackets" href="#id15" id="id7">6</a>.</p>
</section>
<section id="non-virtualizable-cpus">
<h2><span class="section-number">38.6. </span>Non-Virtualizable CPUs<a class="headerlink" href="#non-virtualizable-cpus" title="Permalink to this headline">#</a></h2>
<p>There is a minor problem with the classic trap-and-emulate
virtualization mechanism as described above: it doesn’t work. Or rather,
it doesn’t work on the machines you want it to work on.</p>
<p>In order to perform classic virtualization to work, every “sensitive”
instruction (in other words, one that has to be emulated, like loading
CR3 to switch page tables) must trap so that it can be emulated by the
hypervisor. Unfortunately, some CPU architectures (in particular, Intel
x86 CPUs) have instructions that fail this requirement. For example, on
x86 CPUs, a number of instructions which modify supervisor-mode state
will silently do nothing when executed in user mode, rather than causing
an exception.</p>
<p><img alt="Sensitive state in the Intel architecture EFLAGS register" src="images/virt/eflags-register.png" />{#fig:virtmach:eflags}</p>
<p>As an example, the EFLAGS register as shown in
<a class="reference external" href="#fig:virtmach:eflags">[fig:virtmach:eflags]</a>{reference-type=”autoref”
reference=”fig:virtmach:eflags”} contains some commonly-used flags such
as carry (CF) and zero (ZF) which it inherited from the 16-bit 8086, as
well as system flags such as interrupt enable and “IO privilege level”,
the CPU user/supervisor privilege level. The POPF instruction modifies
this register, by loading it with a value popped from the top of the
stack. To prevent application code from arbitrarily disabling interrupts
or turning on supervisor mode, when POPF is executed in user mode it
silently ignores any privileged bits like IOPL and interrupt enable;
when kernel code executes POPF in supervisor mode, these bits are loaded
with new values. If we try to run the kernel in user mode this
instruction will silently do the wrong thing, rather than trapping into
the hypervisor.</p>
<p>Instructions like this complicate the task of performing efficient
virtualization, but it is still possible, using one of three approaches:</p>
<ol class="simple">
<li><p><strong>Emulation with binary translation:</strong> This is the simplest approach to
describe, although rather difficult to implement well. Whenever the
guest transitions into supervisor mode (for example, for a system call
or an interrupt) the hypervisor emulates all instructions in software,
using binary to translation speed up this process, and only resuming
direct execution when the guest returns to user mode. This is slower for
normal instructions in the kernel, but faster for privileged
instructions, as it can translate them once instead of incurring the
overhead of trapping and emulating each privileged instruction every
time it executes.</p></li>
<li><p><strong>Hardware virtualization:</strong> Modern x86 CPUs include virtualization
extensions, which add a third privilege level more powerful than
supervisor mode. The guest runs in normal user and supervisor mode, but
certain instructions trap into hypervisor mode for emulation, just as in
trap-and-emulate virtualization on a virtualizable CPU. Which
instructions? It depends: there are configuration registers providing
the hypervisor with a menu of which operations it wants to intercept.</p></li>
<li><p><strong>Paravirtualization:</strong> rather than providing complete emulation of the
hardware platform, the hypervisor provides an OS-like interface so that
the operating system can request operations (e.g. address space switch)
which would be performed by hardware instructions (e.g. LOAD CR3) on
bare hardware. The guest operating system must be modified to use these
requests, and so while binary translation and hardware virtualization
can run unmodified guest operating systems (e.g. standard Windows
installation media) paravirtualization can only support guest operating
systems which have been modified for paravirtualization.</p></li>
</ol>
<p>The changes required in a guest OS are actually not that extensive, as
most modern operating systems (even Windows) are structured so that they
can be (relatively) easily modified to support different machine types,
with hardware-specific portions isolated into a small, replaceable part
of the code.</p>
<p>A paravirtualized hypervisor looks sort of like a regular OS: it runs in
supervisor mode, with guests running in user mode making requests via
system calls using TRAP instructions. Unlike a normal OS, however, these
system calls perform hardware-level operations like loading a page
table, allocating physical memory, or installing a page fault handler.</p>
<aside class="sidebar">
<p>If you’re curious, the Linux code to switch address spaces can be found
in the <code class="docutils literal notranslate"><span class="pre">activate_mm</span></code> macro in
<span class="xref myst">arch/x86/include/asm/context.h</span>{.uri}.
On regular hardware it calls <code class="docutils literal notranslate"><span class="pre">switch_mm</span></code> which executes a <code class="docutils literal notranslate"><span class="pre">LOAD</span> <span class="pre">CR3</span></code>
instruction; in paravirtualized mode it calls <code class="docutils literal notranslate"><span class="pre">paravirt_activate_mm</span></code> (in
<span class="xref myst">arch/x86/include/asm/</span>{.uri}<span class="xref myst">paravirt.h</span>{.uri})
which invokes a “hypercall” to request the hypervisor to perform the
operation.</p>
</aside>
<p>Although paravirtualization requires some modifications to the guest OS,
in some cases it provides higher performance. As an example, the
hypervisor interface can be as efficient as a system call, while
hardware virtualization extensions require many cycles to trap, decode,
and emulate each instruction.</p>
<p>For years Amazon EC2 used a modified version of the Xen paravirtualized
hypervisor, although as hardware virtualization support continues to
improve, this remains the case only for a small number of their instance
types.</p>
<p>What type of virtualization is fastest? This is actually a hard
question—putting something (like virtualization support) into hardware
doesn’t automatically make it faster. State-of-the-art hardware and
software-based (binary translation) hypervisors can have equivalent
performance<a class="footnote-reference brackets" href="#id16" id="id8">7</a>, so the choice between them often comes down to
features.</p>
</section>
<section id="paravirtualized-i-o-devices">
<h2><span class="section-number">38.7. </span>Paravirtualized I/O Devices<a class="headerlink" href="#paravirtualized-i-o-devices" title="Permalink to this headline">#</a></h2>
<p>It is common for hypervisors to have optional drivers (VMware Tools,
VirtualBox Guest Additions, etc.) which can be loaded in the guest to
improve performance. These typically include paravirtualized drivers for
the disk controller and network interface: rather than catching writes
to emulated registers, the paravirtualized driver uses a system
call-like interface to make I/O requests to the hypervisor. Note that
this works because almost all operating systems provide a simple means
to load arbitrary kernel-mode drivers for third-party hardware; a
paravirtualized device is just another piece of (virtualized) hardware
that you need to install a driver for. In contrast, operating systems
writers don’t typically anticipate the need to support plugging in a
different type of CPU.</p>
</section>
<section id="linux-containers-and-docker">
<h2><span class="section-number">38.8. </span>Linux Containers and Docker<a class="headerlink" href="#linux-containers-and-docker" title="Permalink to this headline">#</a></h2>
<p>Running different applications within separate virtual machines provides
a number of benefits when compared to running them all on the same
unvirtualized operating system:</p>
<ol class="simple">
<li><p>Security—if one application is compromised, or is untrusted, the only
way for it to attack the other applications (other than via the external
network) is by subverting the hypervisor. This is difficult, as they are
small and have tended to be quite reliable in practice. (i.e. with few
bugs that can be exploited)</p></li>
<li><p>Performance isolation—server-class virtualization systems can enforce
resource limits (memory, CPU time, disk and network I/O) which ensure
that heavy loads on one application do not negatively impact another.</p></li>
<li><p>Management isolation—each virtual machine has its own file system,
administrative (root) account, installed libraries, etc. and can be
configured without regard to the dependencies of other applications
running in other virtual machines.</p></li>
<li><p>Packaging convenience—a virtual machine image is a convenient and
useful format for storing a virtual machine and all of its
configuration, as well as for distributing it to others. (like the
CS-5600 virtual machine image you received at the beginning of this
class)</p></li>
</ol>
<p>Note, however, that none of these benefits actually <em>requires</em> hardware
virtualization<a class="footnote-reference brackets" href="#id17" id="id9">8</a>. If all of the applications are going to be running
on the same operating system, then <em>Operating System Virtualization</em> can
be used: rather than pretending that a single hardware machine is
actually multiple virtual machines, we pretend that a single instance of
the operating system is actually multiple instances. This approach was
first used in FreeBSD <em>jails</em> and Solaris <em>containers</em>, but the mostly
widely known example today is Linux Containers (LXC) and Docker.</p>
<p>LXC allows the creation of isolated process groups: each process in such
a group (and any children of those processes) thinks that the group has
the entire operating system to itself. This is done via two mechanisms:</p>
<p><strong>Namespaces</strong> - in recent Linux versions, any access to the file
system, process ID, networking, user or group IDs, or several more
obscure system parameters (e.g. hostname) is relative to a <em>namespace</em>.
In a normal system with no containers there will be a single namespace,
visible to all processes. (or at least those that have sufficient
permission, in the case of e.g. file system access) However you can also
create new namespaces, with a restricted view of the file system (e.g.
only able to see a small subtree), with their own process ID space and
user names and IDs, and separate network interfaces and addresses.
Within a namespace you can have a root user which can perform privileged
operations within the namespace, but which has no power or visibility
outside of it.</p>
<p><strong>Control groups (cgroups)</strong> - these are used to control operating
system allocation of resources such as memory, CPU time, or disk and
network bandwidth. A cgroup can be associated with a process group, and
the process group as a whole will be subject to any limits (e.g. on
memory, CPU time, etc.) placed on that cgroup.</p>
<p>The combination of these two features allows the creation of separate
<em>containers</em>, each with its own file system, network interfaces, etc.,
and where processes within a container are isolated from those in other
containers or in the “base” or root operating system within which these
containers were created. Processes in a container interact with the OS
kernel in exactly the same way as in a non-containerized system; the
only difference is in what they <em>see</em>, which is controlled via
namespaces, and how their CPU time and I/O are <em>scheduled</em>, which is
controlled via cgroups. Containers are thus more efficient, as there is
no virtualization overhead, and can be created almost as quickly as
normal processes.</p>
<p>Since there is still a single operating system kernel, all containers in
a system share the same operating system version. Note, however, that
they may have entirely different file systems; thus it is quite possible
to have both a Red Hat and an Ubuntu distribution running in separate
containers on the same machine, although each will be using the kernel
of the underlying system.</p>
<p>Docker is based on LXC; however perhaps its main innovation is the way
in which it manages container file systems. A Docker container uses a
<em>union file system</em> to join together multiple file systems—the first
one of which is writeable, and with one or more read-only ones “behind”
it. To understand the operation of a union file system, consider how the
Unix shell finds an executable: it searches each directory in the PATH
variable in order, and takes the first version of the file that it
finds. Thus if the value of PATH is <code class="docutils literal notranslate"><span class="pre">/usr/bin:/sbin:/bin</span></code>, and you type
<code class="docutils literal notranslate"><span class="pre">ls</span></code>, it will search <code class="docutils literal notranslate"><span class="pre">/usr/bin/ls</span></code> (not found), <code class="docutils literal notranslate"><span class="pre">/sbin/ls</span></code> (not found),
and then <code class="docutils literal notranslate"><span class="pre">/bin/ls</span></code> (successful). A union file system operates in a
similar fashion: on read access to a file (or directory) it will search
through each underlying file system in order until it is found. When
writing to a file, however, it will write to the first writable file
system in the list, providing a form of copy-on-write.</p>
<p>This allows various environments to be <em>stacked</em>: e.g. a base file
system containing the files from a minimal Linux installation, with
additional file systems “on top” of it containing installed versions of
various packages one wishes to use, and a writable file system on top
for per-instance configuration parameters, application data, etc.</p>
<section id="answers-to-review-questions">
<h3><span class="section-number">38.8.1. </span>Answers to Review Questions<a class="headerlink" href="#answers-to-review-questions" title="Permalink to this headline">#</a></h3>
<ol class="simple">
<li><p>in virtmach:1,virtmach:2,virtmach:3,virtmach:4</p></li>
</ol>
</section>
</section>
<section id="containers">
<span id="virt-containers"></span><h2><span class="section-number">38.9. </span>Containers<a class="headerlink" href="#containers" title="Permalink to this headline">#</a></h2>
</section>
<section id="cloud-computing">
<span id="virt-cloud"></span><h2><span class="section-number">38.10. </span>Cloud Computing<a class="headerlink" href="#cloud-computing" title="Permalink to this headline">#</a></h2>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="id10"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>Early operating systems were often called <em>supervisors</em>; what do
you call the program which supervises the supervisor? A hypervisor,
I guess.</p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">kernel/</span></code> and <code class="docutils literal notranslate"><span class="pre">mm/</span></code> directories in the Linux source add up to
about a third of a million lines of code; support for Intel CPUs in
<code class="docutils literal notranslate"><span class="pre">arch/x86/</span></code> is another third of a million; the <code class="docutils literal notranslate"><span class="pre">drivers/</span></code> directory
is over ten million LOC.</p>
</dd>
<dt class="label" id="id12"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>or, actually, running any OS on top of any OS including itself</p>
</dd>
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id5">4</a></span></dt>
<dd><p>on the right processors, as described below</p>
</dd>
<dt class="label" id="id14"><span class="brackets"><a class="fn-backref" href="#id6">5</a></span></dt>
<dd><p>Or the immediately following instruction in the case of <em>traps</em>
such as system calls.</p>
</dd>
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id7">6</a></span></dt>
<dd><p>That’s how it works with binary emulation. With hardware
virtualization support, the CPU has provisions to allow the “root”
environment to continue to run without virtualization, but it’s
complicated.</p>
</dd>
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id8">7</a></span></dt>
<dd><p>citation here - Ageson</p>
</dd>
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id9">8</a></span></dt>
<dd><p>That is, unless you need to run multiple different operating
systems.</p>
</dd>
</dl>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./virt"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../misc/OtherInro.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">37. </span>Overview of other topics</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../intro/other.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">39. </span>Other OS structures</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By (see contributing chapter book)<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>